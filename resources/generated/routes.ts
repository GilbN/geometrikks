// AUTO-GENERATED by litestar-vite. Do not edit.
/* eslint-disable */

// API base URL - only needed for separate dev servers
// Set VITE_API_URL=http://localhost:8000 when running Vite separately
const API_URL = (typeof import.meta !== 'undefined' && (import.meta as any).env?.VITE_API_URL) ?? '';

/** Semantic string aliases derived from OpenAPI `format`. */
/** ISO 8601 date string (YYYY-MM-DD) */
export type DateOnly = string;

/** RFC 3339 date-time string */
export type DateTime = string;

/** URI/URL string */
export type URI = string;


/** All available route names */
export type RouteName =
  | 'get_bandwidth_time_series'
  | 'get_geo_events_time_series'
  | 'get_geojson'
  | 'get_live_summary'
  | 'get_performance_time_series'
  | 'get_requests_time_series'
  | 'get_summary'
  | 'list_access_log_debugs'
  | 'list_access_logs'
  | 'list_geo_events'
  | 'list_geo_locations'
  | 'openapi.json'
  | 'openapi.yaml'
  | 'read_settings'
  | 'stats'
  | 'vite'
  | 'vite_spa'
  | 'vite_spa_path:path';

/** Path parameter definitions per route */
export interface RoutePathParams {
  'get_bandwidth_time_series': Record<string, never>;
  'get_geo_events_time_series': Record<string, never>;
  'get_geojson': Record<string, never>;
  'get_live_summary': Record<string, never>;
  'get_performance_time_series': Record<string, never>;
  'get_requests_time_series': Record<string, never>;
  'get_summary': Record<string, never>;
  'list_access_log_debugs': Record<string, never>;
  'list_access_logs': Record<string, never>;
  'list_geo_events': Record<string, never>;
  'list_geo_locations': Record<string, never>;
  'openapi.json': Record<string, never>;
  'openapi.yaml': Record<string, never>;
  'read_settings': Record<string, never>;
  'stats': Record<string, never>;
  'vite': {
    file_path: any;
  };
  'vite_spa': Record<string, never>;
  'vite_spa_path:path': {
    path: URI;
  };
}

/** Query parameter definitions per route */
export interface RouteQueryParams {
  'get_bandwidth_time_series': {
    end_date: DateOnly;
    granularity?: "hourly" | "daily";
    start_date: DateOnly;
  };
  'get_geo_events_time_series': {
    end_date: DateOnly;
    granularity?: "hourly" | "daily";
    start_date: DateOnly;
  };
  'get_geojson': {
    from_timestamp: DateTime;
    to_timestamp: DateTime;
  };
  'get_live_summary': {
    compare_previous?: boolean;
    end_date: DateTime;
    start_date: DateTime;
  };
  'get_performance_time_series': {
    end_date: DateOnly;
    granularity?: "hourly" | "daily";
    start_date: DateOnly;
  };
  'get_requests_time_series': {
    end_date: DateOnly;
    granularity?: "hourly" | "daily";
    start_date: DateOnly;
  };
  'get_summary': {
    compare_previous?: boolean;
    end_date: DateTime;
    start_date: DateTime;
  };
  'list_access_log_debugs': {
    currentPage?: number;
    pageSize?: number;
  };
  'list_access_logs': {
    currentPage?: number;
    pageSize?: number;
  };
  'list_geo_events': {
    currentPage?: number;
    pageSize?: number;
  };
  'list_geo_locations': {
    currentPage?: number;
    pageSize?: number;
  };
  'openapi.json': Record<string, never>;
  'openapi.yaml': Record<string, never>;
  'read_settings': Record<string, never>;
  'stats': Record<string, never>;
  'vite': Record<string, never>;
  'vite_spa': Record<string, never>;
  'vite_spa_path:path': Record<string, never>;
}

type EmptyParams = Record<string, never>
type MergeParams<A, B> =
  A extends EmptyParams ? (B extends EmptyParams ? EmptyParams : B) : B extends EmptyParams ? A : A & B

/** Combined parameters (path + query) */
export type RouteParams<T extends RouteName> = MergeParams<RoutePathParams[T], RouteQueryParams[T]>

/** Route metadata */
export const routeDefinitions = {
  'get_bandwidth_time_series': {
    path: '/api/v1/analytics/time-series/bandwidth',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['end_date', 'granularity', 'start_date'] as const,
  },
  'get_geo_events_time_series': {
    path: '/api/v1/analytics/time-series/geo-events',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['end_date', 'granularity', 'start_date'] as const,
  },
  'get_geojson': {
    path: '/api/v1/geo-locations/geojson',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['from_timestamp', 'to_timestamp'] as const,
  },
  'get_live_summary': {
    path: '/api/v1/analytics/live-summary',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['compare_previous', 'end_date', 'start_date'] as const,
  },
  'get_performance_time_series': {
    path: '/api/v1/analytics/time-series/performance',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['end_date', 'granularity', 'start_date'] as const,
  },
  'get_requests_time_series': {
    path: '/api/v1/analytics/time-series/requests',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['end_date', 'granularity', 'start_date'] as const,
  },
  'get_summary': {
    path: '/api/v1/analytics/summary',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['compare_previous', 'end_date', 'start_date'] as const,
  },
  'list_access_log_debugs': {
    path: '/api/v1/access-log-debug',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['currentPage', 'pageSize'] as const,
  },
  'list_access_logs': {
    path: '/api/v1/access-logs',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['currentPage', 'pageSize'] as const,
  },
  'list_geo_events': {
    path: '/api/v1/geo-events',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['currentPage', 'pageSize'] as const,
  },
  'list_geo_locations': {
    path: '/api/v1/geo-locations',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: ['currentPage', 'pageSize'] as const,
  },
  'openapi.json': {
    path: '/schema/openapi.json',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: [] as const,
  },
  'openapi.yaml': {
    path: '/schema/openapi.yaml',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: [] as const,
  },
  'read_settings': {
    path: '/settings',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: [] as const,
  },
  'stats': {
    path: '/stats',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: [] as const,
  },
  'vite': {
    path: '/static/{file_path}',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: ['file_path'] as const,
    queryParams: [] as const,
  },
  'vite_spa': {
    path: '/',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: [] as const,
    queryParams: [] as const,
  },
  'vite_spa_path:path': {
    path: '/{path}',
    methods: ['GET'] as const,
    method: 'get',
    pathParams: ['path'] as const,
    queryParams: [] as const,
  },
} as const

/** Check if path params are required for a route */
type HasRequiredPathParams<T extends RouteName> =
  RoutePathParams[T] extends Record<string, never> ? false : true;

/** Check if query params have any required fields */
type HasRequiredQueryParams<T extends RouteName> =
  RouteQueryParams[T] extends Record<string, never>
    ? false
    : Partial<RouteQueryParams[T]> extends RouteQueryParams[T]
      ? false
      : true;

/** Routes that require parameters (path or query) */
type RoutesWithRequiredParams = {
  [K in RouteName]: HasRequiredPathParams<K> extends true
    ? K
    : HasRequiredQueryParams<K> extends true
      ? K
      : never;
}[RouteName];

/** Routes without any required parameters */
type RoutesWithoutRequiredParams = Exclude<RouteName, RoutesWithRequiredParams>;

/**
 * Generate a URL for a named route.
 *
 * @example
 * route('books')                              // '/api/books'
 * route('book_detail', { book_id: 123 })      // '/api/books/123'
 * route('search', { q: 'test', limit: 5 })    // '/api/search?q=test&limit=5'
 *
 * // Access HTTP method from route definition when needed:
 * routeDefinitions.login.method               // 'post'
 */
export function route<T extends RoutesWithoutRequiredParams>(name: T): string;
export function route<T extends RoutesWithoutRequiredParams>(
  name: T,
  params?: RouteParams<T>,
): string;
export function route<T extends RoutesWithRequiredParams>(
  name: T,
  params: RouteParams<T>,
): string;
export function route<T extends RouteName>(
  name: T,
  params?: RouteParams<T>,
): string {
  const def = routeDefinitions[name];
  let url: string = def.path;

  // Replace path parameters (use replaceAll to handle multiple occurrences)
  if (params) {
    for (const param of def.pathParams) {
      const value = (params as Record<string, unknown>)[param];
      if (value !== undefined) {
        url = url.replaceAll("{" + param + "}", String(value));
      }
    }
  }

  // Add query parameters
  if (params) {
    const queryParts: string[] = [];
    for (const param of def.queryParams) {
      const value = (params as Record<string, unknown>)[param];
      if (value !== undefined) {
        queryParts.push(encodeURIComponent(param) + "=" + encodeURIComponent(String(value)));
      }
    }
    if (queryParts.length > 0) {
      url += "?" + queryParts.join("&");
    }
  }

  // Apply API URL if set (for separate dev servers)
  return API_URL ? API_URL.replace(/\/$/, '') + url : url;
}

/** Check if a route exists */
export function hasRoute(name: string): name is RouteName {
  return name in routeDefinitions;
}

/** Get all route names */
export function getRouteNames(): RouteName[] {
  return Object.keys(routeDefinitions) as RouteName[];
}

/** Get route metadata */
export function getRoute<T extends RouteName>(name: T): (typeof routeDefinitions)[T] {
  return routeDefinitions[name];
}

// ============================================================================
// Route Matching Helpers
// ============================================================================

/** Cache for compiled route patterns */
const patternCache = new Map<string, RegExp>();

/**
 * Compile a route path pattern to a regex for URL matching.
 * Results are cached for performance.
 */
function compilePattern(path: string): RegExp {
  const cached = patternCache.get(path);
  if (cached) return cached;

  // Escape special regex characters except { }
  let pattern = path.replace(/[.*+?^$|()\[\]]/g, '\\$&');
  // Replace {param} or {param:type} with matchers
  pattern = pattern.replace(/\{([^}]+)\}/g, (_match, paramSpec: string) => {
    const paramType = paramSpec.includes(':') ? paramSpec.split(':')[1] : 'str';
    switch (paramType) {
      case 'uuid':
        return '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}';
      case 'path':
        return '.*';
      case 'int':
        return '\\d+';
      default:
        return '[^/]+';
    }
  });
  const regex = new RegExp(`^${pattern}$`, 'i');
  patternCache.set(path, regex);
  return regex;
}

/**
 * Convert a URL to its corresponding route name.
 *
 * @param url - URL or path to match (query strings and hashes are stripped)
 * @returns The matching route name, or null if no match found
 *
 * @example
 * toRoute('/api/books')        // 'books'
 * toRoute('/api/books/123')    // 'book_detail'
 * toRoute('/unknown')          // null
 */
export function toRoute(url: string): RouteName | null {
  // Strip query string and hash
  const path = url.split('?')[0].split('#')[0];
  // Normalize: remove trailing slash except for root
  const normalized = path === '/' ? path : path.replace(/\/$/, '');

  for (const [name, def] of Object.entries(routeDefinitions)) {
    if (compilePattern(def.path).test(normalized)) {
      return name as RouteName;
    }
  }
  return null;
}

/**
 * Get the current route name based on the browser URL.
 * Returns null in SSR/non-browser environments.
 *
 * @returns Current route name, or null if no match or not in browser
 *
 * @example
 * // On page /api/books/123
 * currentRoute()  // 'book_detail'
 */
export function currentRoute(): RouteName | null {
  if (typeof window === 'undefined') return null;
  return toRoute(window.location.pathname);
}

/**
 * Check if a URL matches a route name or pattern.
 * Supports wildcard patterns with `*` to match multiple routes.
 *
 * @param url - URL or path to check
 * @param pattern - Route name or pattern (e.g., 'books', 'book_*', '*_detail')
 * @returns True if the URL matches the route pattern
 *
 * @example
 * isRoute('/api/books', 'books')           // true
 * isRoute('/api/books/123', 'book_*')      // true (wildcard)
 */
export function isRoute(url: string, pattern: string): boolean {
  const routeName = toRoute(url);
  if (!routeName) return false;
  // Escape special regex chars (except *), then convert * to .*
  const escaped = pattern.replace(/[.+?^$|()\[\]{}]/g, '\\$&');
  const regex = new RegExp(`^${escaped.replace(/\*/g, '.*')}$`);
  return regex.test(routeName);
}

/**
 * Check if the current browser URL matches a route name or pattern.
 * Supports wildcard patterns with `*` to match multiple routes.
 * Returns false in SSR/non-browser environments.
 *
 * @param pattern - Route name or pattern (e.g., 'books', 'book_*', '*_page')
 * @returns True if current URL matches the route pattern
 *
 * @example
 * // On page /books
 * isCurrentRoute('books_page')  // true
 * isCurrentRoute('*_page')      // true (wildcard)
 */
export function isCurrentRoute(pattern: string): boolean {
  const current = currentRoute();
  if (!current) return false;
  // Escape special regex chars (except *), then convert * to .*
  const escaped = pattern.replace(/[.+?^$|()\[\]{}]/g, '\\$&');
  const regex = new RegExp(`^${escaped.replace(/\*/g, '.*')}$`);
  return regex.test(current);
}
